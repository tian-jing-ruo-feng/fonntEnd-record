---
sidebarDepth: 2
sidebar: auto
---

# 灵活的 JavaScript

## 面向对象编程

### 函数

```js
function checkName() {
  // 验证姓名
}
function checkAge() {
  // 验证年龄
}
function checkEmail() {
  // 验证邮箱
}
```

### 使用对象收编变量

```js
var CheckObject = {
  checkName: function () {},
  checkAge: function () {},
  checkEmail: function () {}
}
```

### 对象的另一种方式

::: tip
对于方法一使用 new 关键子创建的对象不能使用这些静态方法
:::

```js
// 对象方法一
var CheckObject = function () {}
CheckObject.checkName = function () {}
CheckObject.checkAge = function () {}
CheckObject.checkEmail = function () {}

// 对象方法二
var CheckObject = function () {
  return {
    checkName: function () {},
    checkAge: function () {},
    checkEmail: function () {}
  }
}

// 使用类返回一个对像
var CheckObject = function () {
  this.checkName = function () {}
  this.checkAge = function () {}
  this.checkEmail = function () {}
}
```

### 定义一个检测类

```js
// 定义一个构造函数
var CheckObject = function () {}
CheckObject.prototype = {
  checkAge: function () {
    return this
  },
  checkName: function () {
    return this
  },
  checkEmail: function () {
    return this
  }
}

var check = new CheckObject()
// 链式调用
check.checkAge().checkEmail().checkName()
```

### 通过函数的祖先添加方法

```js
// 方法一
Function.prototype.addMethod = function (name, fn) {
  this[name] = fn
  return this
}
var method = function () {}
method
  .addMethod('checkName', function () {
    return this
  })
  .addMethod('checkAge', function () {
    return this
  })
  .addMethod('checkEmail', function () {
    return this
  })

// 方法二

Function.prototype.addMethod = function (name, fn) {
  this.prototype[name] = fn
}
var Mehthods = function () {}
Mehthods.addMethod('checkName', function () {
  // 验证姓名
}).addMethod('checkAge', function () {
  // 验证年龄
})
var check = new Mehthods()
check.checkName().checkAge()
```

### 测试使用 badge

::: tip
对于使用 new 关键子创建的对象不能使用这些静态方法
:::
::: danger
对于使用 new 关键子创建的对象不能使用这些静态方法
:::
::: warning
对于使用 new 关键子创建的对象不能使用这些静态方法
:::
::: details
对于使用 new 关键子创建的对象不能使用这些静态方法
:::

```

```
